<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Profil coloré continu selon pente</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.7.0/gpx.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@raruto/leaflet-elevation/dist/leaflet-elevation.min.css" />
<script src="https://unpkg.com/@raruto/leaflet-elevation/dist/leaflet-elevation.min.js"></script>

<style>
    body { margin:0; font-family:Arial; }
    #map { height: 50vh; }
    #profile { height: 40vh; }
</style>
</head>
<body>
<div id="map"></div>
<div id="profile"></div>

<script>
// --- Carte ---
const map = L.map("map");
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

// --- Profil ---
const elevation = L.control.elevation({
    container: "#profile",
    elevationDiv: "#profile",
    followMarker: true,
    slope: false,  // désactive tracé slope rouge
    summary: true,
    useHeightIndicator: true,
    autofitBounds: true,
    time: false,
    legend: false,
    distanceMarkers: true
}).addTo(map);

let hoverMarker = null;

// Fonction couleur continue selon pente
function getSlopeColor(slope){
    if(slope < 0) return "#0000ff";
    if(slope < 5) return "#00ff00";
    return "#ff0000";
}

// --- Charger GPX ---
const gpxFile = "TRAIL 10KM.gpx";

new L.GPX(gpxFile, {async:true})
.on("loaded", e => map.fitBounds(e.target.getBounds()))
.on("addline", function(e){
    const coords = e.line.getLatLngs();
    const canvasLine = [];

    for(let i=1; i<coords.length; i++){
        const p1 = coords[i-1], p2 = coords[i];
        const dist = map.distance(p1,p2);
        const dz = p2.alt - p1.alt;
        const slope = (dz/dist)*100;

        // Stocke chaque segment avec sa couleur
        canvasLine.push({from: p1, to: p2, color: getSlopeColor(slope)});
    }

    // Dessiner chaque segment dans le profil
    canvasLine.forEach(seg => elevation.addData(L.polyline([seg.from, seg.to], {color: seg.color})));

    // Survol carte → curseur sur profil
    e.line.on("mousemove", ev => {
        const latlng = ev.latlng;
        if(!latlng) return;
        if(!hoverMarker){
            hoverMarker = L.circleMarker(latlng, {radius:6,weight:2,color:"red",fillColor:"white",fillOpacity:0.9}).addTo(map);
        } else hoverMarker.setLatLng(latlng);
    });
})
.addTo(map);

// Survol profil → cercle sur carte
elevation.on("elemousemove", ev => {
    const latlng = ev.latlng;
    if(!latlng) return;
    if(!hoverMarker){
        hoverMarker = L.circleMarker(latlng, {radius:6,weight:2,color:"red",fillColor:"white",fillOpacity:0.9}).addTo(map);
    } else hoverMarker.setLatLng(latlng);
});

// Axe X et distance
elevation.options.xTicks = 10;
elevation._xTickFormat = d => Math.floor(d/1000);
elevation._distanceFormat = d => (d/1000).toFixed(2) + " km";
</script>
</body>
</html>
