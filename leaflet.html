<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Carte + Profil Altimétrique Synchronisés</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/1.5.1/gpx.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; background: #f4f4f4; }
    #map { height: 50vh; width: 100%; cursor: crosshair; } /* Curseur changé pour indiquer l'interactivité */
    #stats { background: white; padding: 15px; margin: 10px; border-radius: 12px; box-shadow: 0 3px 10px rgba(0,0,0,0.15); }
    #profileContainer { width: 95%; margin: auto; background: white; padding: 15px; border-radius: 12px; box-shadow: 0 3px 10px rgba(0,0,0,0.15); }
    canvas { width: 100% !important; max-height: 280px; }
    @media (max-width: 600px) { #map { height: 45vh; } canvas { max-height: 220px; } }
  </style>
</head>

<body>

<div id="map"></div>

<div id="stats">
  <h2>Statistiques</h2>
  <div id="statsContent">Chargement…</div>
</div>

<div id="profileContainer">
  <h2>Profil Altimétrique (Interactif)</h2>
  <canvas id="elevationChart"></canvas>
</div>

<script>
  // ----------------------------------------------------------
  // 1. Initialisation Leaflet
  // ----------------------------------------------------------
  const map = L.map("map");
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap",
  }).addTo(map);

  // Création d'un marqueur de suivi (point bleu)
  // Il est initialement caché (opacity 0)
  const focusMarker = L.circleMarker([0, 0], {
    radius: 8,
    color: 'white',
    weight: 2,
    fillColor: '#007bff',
    fillOpacity: 1
  }).addTo(map);
  
  // On cache le marker au début tant qu'on ne survole pas
  focusMarker.getElement().style.display = 'none'; 

  function colorForSlope(p) {
    if (p < 4) return "green";
    if (p < 7) return "yellow";
    if (p < 12) return "orange";
    return "red";
  }

  // ----------------------------------------------------------
  // 2. Chargement GPX
  // ----------------------------------------------------------
  // REMPLACEZ CECI PAR VOTRE FICHIER
  const gpxFile = "TRAIL 10KM.gpx"; 

  const gpx = new L.GPX(gpxFile, {
    async: true,
    marker_options: { startIconUrl: "", endIconUrl: "", shadowUrl: "" },
    polyline_options: { color: "#d00", weight: 4, opacity: 0.9 },
  })
  .on("loaded", function (e) {
      map.fitBounds(e.target.getBounds());
  })
  .on("addline", function (e) {
      const line = e.line;
      const latlngs = line.getLatLngs();

      // --- Préparation des données ---
      const distances = [];
      const elevations = [];
      const slopes = [];
      let totalDist = 0;
      let totalUP = 0;
      let totalDOWN = 0;

      for (let i = 0; i < latlngs.length; i++) {
        if (i > 0) {
          const d = latlngs[i - 1].distanceTo(latlngs[i]);
          totalDist += d;
          const diff = latlngs[i].meta.ele - latlngs[i - 1].meta.ele;
          if (diff > 0) totalUP += diff; else totalDOWN += Math.abs(diff);
          slopes.push((diff / d) * 100);
        }
        distances.push(totalDist / 1000);
        elevations.push(latlngs[i].meta.ele);
      }

      // --- Affichage Stats ---
      document.getElementById("statsContent").innerHTML = `
        <b>Distance :</b> ${(totalDist / 1000).toFixed(2)} km | 
        <b>D+ :</b> ${Math.round(totalUP)} m | 
        <b>D- :</b> ${Math.round(totalDOWN)} m
      `;

      // --- Configuration Chart.js ---
      const ctx = document.getElementById("elevationChart").getContext("2d");
      const gradientColor = elevations.map((_, i) => i === 0 ? "green" : colorForSlope(slopes[i - 1]));

      const myChart = new Chart(ctx, {
        type: "line",
        data: {
          labels: distances,
          datasets: [{
            label: "Altitude (m)",
            data: elevations,
            segment: {
              borderColor: ctx => gradientColor[ctx.p0DataIndex],
              borderWidth: 3,
            },
            pointRadius: 0,
            pointHoverRadius: 5, // Plus gros quand survolé
            fill: true,
            backgroundColor: 'rgba(0,0,0,0.05)'
          }],
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            tooltip: {
                enabled: true, // On garde l'infobulle
                animation: false // Plus fluide pour la synchro
            }
          },
          scales: {
            x: { title: { display: true, text: "Distance (km)" }, ticks: { maxTicksLimit: 10 } },
            y: { title: { display: true, text: "Altitude (m)" } },
          },
          
          // --- SYNC CHART VERS MAP ---
          onHover: (event, activeElements) => {
            if (activeElements && activeElements.length > 0) {
                const index = activeElements[0].index;
                const coord = latlngs[index];
                
                // Afficher et déplacer le marker
                focusMarker.setLatLng(coord);
                focusMarker.getElement().style.display = 'block';
            } else {
                // Optionnel : cacher si on sort du graph
                // focusMarker.getElement().style.display = 'none';
            }
          }
        },
      });

      // --- SYNC MAP VERS CHART ---
      // On écoute le mouvement de la souris sur la carte
      map.on('mousemove', function(e) {
        // 1. Trouver le point du tracé le plus proche de la souris
        let closestIndex = -1;
        let minDistance = Infinity;

        // Note: Pour un tracé < 10 000 points, cette boucle est très rapide
        // Pour des tracés énormes, il faudrait optimiser.
        for (let i = 0; i < latlngs.length; i++) {
            const d = e.latlng.distanceTo(latlngs[i]);
            if (d < minDistance) {
                minDistance = d;
                closestIndex = i;
            }
        }

        // Si on est assez proche du tracé (ex: moins de 500m virtuels ou juste le plus proche)
        // Ici on prend juste le plus proche pour l'effet fluide.
        if (closestIndex > -1) {
            // 2. Déplacer le marker bleu
            const coord = latlngs[closestIndex];
            focusMarker.setLatLng(coord);
            focusMarker.getElement().style.display = 'block';

            // 3. Activer l'infobulle du Chart
            const chart = Chart.getChart("elevationChart");
            
            // Déclenche le hover visuel sur le graphique
            chart.setActiveElements([{datasetIndex: 0, index: closestIndex}]);
            chart.tooltip.setActiveElements([{datasetIndex: 0, index: closestIndex}]);
            chart.update();
        }
      });
      
      // Cacher le marker si on sort de la carte
      map.on('mouseout', function() {
         focusMarker.getElement().style.display = 'none';
         // Reset du chart si désiré
         myChart.setActiveElements([]);
         myChart.tooltip.setActiveElements([], {x: 0, y: 0});
         myChart.update();
      });

  })
  .addTo(map);

</script>
</body>
</html>
