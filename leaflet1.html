<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Affichage trace + graphique dénivelé</title>
  <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    html,body { height:100%; margin:0; }
    #map { position:absolute; top:0; bottom:0; right:0; left:0; }
    #chart-container {
      position:absolute;
      bottom:0;
      left:0;
      right:0;
      height:220px;
      background:white;
      z-index:9999;
      box-shadow:0 -2px 6px rgba(0,0,0,0.2);
    }
    canvas { width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="chart-container"><canvas id="elevChart"></canvas></div>

  <script>
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'osm-tiles': {
            type: 'raster',
            tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
            tileSize: 256,
            attribution:'© OpenStreetMap'
          }
        },
        layers: [{ id:'osm-tiles', type:'raster', source:'osm-tiles' }]
      },
      center: [0,0], zoom: 2
    });

    map.addControl(new maplibregl.NavigationControl());

    function computeBBox(geojson) {
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      function scan(c){ if(typeof c[0]==='number'){minX=Math.min(minX,c[0]);minY=Math.min(minY,c[1]);maxX=Math.max(maxX,c[0]);maxY=Math.max(maxY,c[1]);}
                         else c.forEach(scan);}      
      if(geojson.type==='FeatureCollection') geojson.features.forEach(f=>f.geometry&&scan(f.geometry.coordinates));
      else scan(geojson.coordinates);
      return [[minX,minY],[maxX,maxY]];
    }

    fetch('trail_10km.geojson')
      .then(r=>r.json())
      .then(geojson=>{
        map.addSource('trail',{type:'geojson',data:geojson});

        map.addLayer({
          id:'trail-line', type:'line', source:'trail',
          paint:{'line-color':'#e91e63','line-width':4}
        });

        let coords=null;
        if(geojson.type==='FeatureCollection'){
          const f=geojson.features.find(f=>f.geometry.type==='LineString');
          coords=f?f.geometry.coordinates:null;
        }
        if(!coords) return;

        const bbox=computeBBox(geojson);
        map.fitBounds(bbox,{padding:40});

        const distances=[0];
        const elevations=[];
        for(let i=0;i<coords.length;i++){
          const elev=coords[i][2]||0;
          elevations.push(elev);
          if(i>0){
            const dx=coords[i][0]-coords[i-1][0];
            const dy=coords[i][1]-coords[i-1][1];
            const dist=Math.sqrt(dx*dx+dy*dy)*111000;
            distances.push(distances[i-1]+dist);
          }
        }

        const slopes=[];
        for(let i=1;i<elevations.length;i++){
          const dh=elevations[i]-elevations[i-1];
          const dd=distances[i]-distances[i-1];
          slopes.push(dd>0?dh/dd:0);
        }
        slopes.unshift(0);

        const ctx=document.getElementById('elevChart').getContext('2d');
        const chart=new Chart(ctx,{
          type:'line',
          data:{ labels:distances, datasets:[{
            label:'Dénivelé', data:elevations, borderWidth:2,
            segment:{ borderColor:ctx=>{
              const i=ctx.p0DataIndex;
              const s=slopes[i];
              if(s>0.15) return 'red';
              if(s>0.05) return 'orange';
              return 'green';
            }}
          }]},
          options:{
            responsive:true,
            interaction:{mode:'nearest',intersect:false},
            scales:{x:{title:{text:'Distance (m)',display:true}}, y:{title:{text:'Altitude (m)',display:true}}},
            onHover:(event,items)=>{
              if(items.length){
                const i=items[0].index;
                const lnglat=[coords[i][0],coords[i][1]];
                if(window.chartMarker) chartMarker.remove();
                window.chartMarker=new maplibregl.Marker({color:'#000'}).setLngLat(lnglat).addTo(map);
                map.easeTo({center:lnglat, duration:200});
              }
            }
          }
        });

        map.on('mousemove','trail-line',e=>{
          const pt=e.lngLat;
          let nearest=0, mind=Infinity;
          coords.forEach((c,i)=>{
            const dx=c[0]-pt.lng, dy=c[1]-pt.lat;
            const d=dx*dx+dy*dy;
            if(d<mind){mind=d;nearest=i;}
          });
          chart.setActiveElements([{datasetIndex:0,index:nearest}]);
          chart.tooltip.setActiveElements([{datasetIndex:0,index:nearest}]);
          chart.update();
        });

      });
  </script>
</body>
</html>
